> Task :clean
> Task :compileJava
> Task :processResources NO-SOURCE
> Task :classes
> Task :jar
> Task :assemble
> Task :compileTestJava NO-SOURCE
> Task :processTestResources NO-SOURCE
> Task :testClasses UP-TO-DATE
> Task :test NO-SOURCE
> Task :check UP-TO-DATE
> Task :build
> Task :compileJmhJava
> Task :processJmhResources NO-SOURCE
> Task :jmhClasses

> Task :jmhRunBytecodeGenerator
Processing 3 classes from /home/ian/Projects/TestCode/jmh-gradle-plugin-change-bug/project_base_working/build/classes/java/jmh with "reflection" generator
Writing out Java source to /home/ian/Projects/TestCode/jmh-gradle-plugin-change-bug/project_base_working/build/jmh-generated-sources and resources to /home/ian/Projects/TestCode/jmh-gradle-plugin-change-bug/project_base_working/build/jmh-generated-resources

> Task :jmhCompileGeneratedClasses
> Task :jmhJar

> Task :jmh
# JMH version: 1.21
# VM version: JDK 11.0.8, OpenJDK 64-Bit Server VM, 11.0.8+10-post-Ubuntu-0ubuntu118.04.1
# VM invoker: /usr/lib/jvm/java-11-openjdk-amd64/bin/java
# VM options: <none>
# Warmup: <none>
# Measurement: 10 iterations, 10 ms each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: com.cool.library.benchmarks.MyClassBenchmark.construct

# Run progress: 0.00% complete, ETA 00:00:00
# Fork: N/A, test runs in the host VM
# *** WARNING: Non-forked runs may silently omit JVM options, mess up profilers, disable compiler hints, etc. ***
# *** WARNING: Use non-forked runs only for debugging purposes, not for actual performance runs. ***
Iteration   1: ≈ 10⁻⁵ ms/op
Iteration   2: ≈ 10⁻⁵ ms/op
Iteration   3: ≈ 10⁻⁵ ms/op
Iteration   4: ≈ 10⁻⁵ ms/op
Iteration   5: ≈ 10⁻⁵ ms/op
Iteration   6: ≈ 10⁻⁴ ms/op
Iteration   7: ≈ 10⁻⁴ ms/op
Iteration   8: ≈ 10⁻⁵ ms/op
Iteration   9: ≈ 10⁻⁴ ms/op
Iteration  10: ≈ 10⁻⁵ ms/op

Result "com.cool.library.benchmarks.MyClassBenchmark.construct":
  ≈ 10⁻⁵ ms/op


# JMH version: 1.21
# VM version: JDK 11.0.8, OpenJDK 64-Bit Server VM, 11.0.8+10-post-Ubuntu-0ubuntu118.04.1
# VM invoker: /usr/lib/jvm/java-11-openjdk-amd64/bin/java
# VM options: <none>
# Warmup: <none>
# Measurement: 10 iterations, 10 ms each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: com.cool.library.benchmarks.MyClassBenchmark.decrement
# Parameters: (numOperations = 1)

# Run progress: 20.00% complete, ETA 00:00:00
# Fork: N/A, test runs in the host VM
# *** WARNING: Non-forked runs may silently omit JVM options, mess up profilers, disable compiler hints, etc. ***
# *** WARNING: Use non-forked runs only for debugging purposes, not for actual performance runs. ***
Iteration   1: ≈ 10⁻⁵ ms/op
Iteration   2: ≈ 10⁻⁵ ms/op
Iteration   3: ≈ 10⁻⁵ ms/op
Iteration   4: ≈ 10⁻⁵ ms/op
Iteration   5: ≈ 10⁻⁵ ms/op
Iteration   6: ≈ 10⁻⁵ ms/op
Iteration   7: ≈ 10⁻⁵ ms/op
Iteration   8: ≈ 10⁻⁵ ms/op
Iteration   9: ≈ 10⁻⁵ ms/op
Iteration  10: ≈ 10⁻⁵ ms/op

Result "com.cool.library.benchmarks.MyClassBenchmark.decrement":
  ≈ 10⁻⁵ ms/op


# JMH version: 1.21
# VM version: JDK 11.0.8, OpenJDK 64-Bit Server VM, 11.0.8+10-post-Ubuntu-0ubuntu118.04.1
# VM invoker: /usr/lib/jvm/java-11-openjdk-amd64/bin/java
# VM options: <none>
# Warmup: <none>
# Measurement: 10 iterations, 10 ms each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: com.cool.library.benchmarks.MyClassBenchmark.decrement
# Parameters: (numOperations = 100000)

# Run progress: 40.00% complete, ETA 00:00:00
# Fork: N/A, test runs in the host VM
# *** WARNING: Non-forked runs may silently omit JVM options, mess up profilers, disable compiler hints, etc. ***
# *** WARNING: Use non-forked runs only for debugging purposes, not for actual performance runs. ***
Iteration   1: 0.319 ms/op
Iteration   2: 0.225 ms/op
Iteration   3: 0.636 ms/op
Iteration   4: 0.502 ms/op
Iteration   5: 0.144 ms/op
Iteration   6: 0.131 ms/op
Iteration   7: 0.211 ms/op
Iteration   8: 0.111 ms/op
Iteration   9: 0.147 ms/op
Iteration  10: 0.211 ms/op

Result "com.cool.library.benchmarks.MyClassBenchmark.decrement":
  0.264 ±(99.9%) 0.264 ms/op [Average]
  (min, avg, max) = (0.111, 0.264, 0.636), stdev = 0.175
  CI (99.9%): [≈ 0, 0.528] (assumes normal distribution)


# JMH version: 1.21
# VM version: JDK 11.0.8, OpenJDK 64-Bit Server VM, 11.0.8+10-post-Ubuntu-0ubuntu118.04.1
# VM invoker: /usr/lib/jvm/java-11-openjdk-amd64/bin/java
# VM options: <none>
# Warmup: <none>
# Measurement: 10 iterations, 10 ms each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: com.cool.library.benchmarks.MyClassBenchmark.increment
# Parameters: (numOperations = 1)

# Run progress: 60.00% complete, ETA 00:00:00
# Fork: N/A, test runs in the host VM
# *** WARNING: Non-forked runs may silently omit JVM options, mess up profilers, disable compiler hints, etc. ***
# *** WARNING: Use non-forked runs only for debugging purposes, not for actual performance runs. ***
Iteration   1: ≈ 10⁻⁵ ms/op
Iteration   2: ≈ 10⁻⁵ ms/op
Iteration   3: ≈ 10⁻⁵ ms/op
Iteration   4: ≈ 10⁻⁵ ms/op
Iteration   5: ≈ 10⁻⁵ ms/op
Iteration   6: ≈ 10⁻⁵ ms/op
Iteration   7: ≈ 10⁻⁵ ms/op
Iteration   8: ≈ 10⁻⁵ ms/op
Iteration   9: ≈ 10⁻⁵ ms/op
Iteration  10: ≈ 10⁻⁵ ms/op

Result "com.cool.library.benchmarks.MyClassBenchmark.increment":
  ≈ 10⁻⁵ ms/op


# JMH version: 1.21
# VM version: JDK 11.0.8, OpenJDK 64-Bit Server VM, 11.0.8+10-post-Ubuntu-0ubuntu118.04.1
# VM invoker: /usr/lib/jvm/java-11-openjdk-amd64/bin/java
# VM options: <none>
# Warmup: <none>
# Measurement: 10 iterations, 10 ms each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: com.cool.library.benchmarks.MyClassBenchmark.increment
# Parameters: (numOperations = 100000)

# Run progress: 80.00% complete, ETA 00:00:00
# Fork: N/A, test runs in the host VM
# *** WARNING: Non-forked runs may silently omit JVM options, mess up profilers, disable compiler hints, etc. ***
# *** WARNING: Use non-forked runs only for debugging purposes, not for actual performance runs. ***
Iteration   1: 0.164 ms/op
Iteration   2: 0.268 ms/op
Iteration   3: 0.158 ms/op
Iteration   4: 0.275 ms/op
Iteration   5: 0.162 ms/op
Iteration   6: 0.246 ms/op
Iteration   7: 0.334 ms/op
Iteration   8: 0.135 ms/op
Iteration   9: 0.142 ms/op
Iteration  10: 0.219 ms/op

Result "com.cool.library.benchmarks.MyClassBenchmark.increment":
  0.210 ±(99.9%) 0.103 ms/op [Average]
  (min, avg, max) = (0.135, 0.210, 0.334), stdev = 0.068
  CI (99.9%): [0.107, 0.313] (assumes normal distribution)


# Run complete. Total time: 00:00:00

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                   (numOperations)  Mode  Cnt   Score    Error  Units
MyClassBenchmark.construct              N/A  avgt   10  ≈ 10⁻⁵           ms/op
MyClassBenchmark.decrement                1  avgt   10  ≈ 10⁻⁵           ms/op
MyClassBenchmark.decrement           100000  avgt   10   0.264 ±  0.264  ms/op
MyClassBenchmark.increment                1  avgt   10  ≈ 10⁻⁵           ms/op
MyClassBenchmark.increment           100000  avgt   10   0.210 ±  0.103  ms/op

Benchmark result is saved to /home/ian/Projects/TestCode/jmh-gradle-plugin-change-bug/project_base_working/build/reports/jmh/results.txt

Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.
Use '--warning-mode all' to show the individual deprecation warnings.
See https://docs.gradle.org/6.5.1/userguide/command_line_interface.html#sec:command_line_warnings

BUILD SUCCESSFUL in 5s
8 actionable tasks: 8 executed
